# 《你不知道的JavaScript》 学习笔记

2022.8.23

## 第一章 作用域

### 1.1LHS/RHS

LHS和RHS分别表示赋值操作的左侧和右侧，赋值操作不仅是`=`，比如函数传参也是赋值操作，赋值操作可以理解
为"赋值操作的目标是谁（LHS）"以及"谁是赋值操作的源头（RHS）"。

`console.log(a)`, `a`的引用是RHS，因为没有对`a`的赋值操作，而是需要查找`a`的值传递给`console.log()`。

`a = 2`则是LHS引用，因为我们并不关心当前的值，而是需要为 =2 这个操作找到目标。

### 1.2作用域嵌套

不论是哪种查询，引擎都会从当前执行的作用域开始查找，若没找到则向外遍历直到全局作用域，无论是否找到，
查找过程都会停止。

### 1.3异常

执行LHS查询时无法查询到变量时，非严格模式下会在全局作用域下创建变量，执行RHS查询失败时，会抛出ReferenceError,
对变量对值进行不合理操作，比如对非函数类型的值进行函数调用，会抛出TypeError。

## 第二章 词法作用域

### 2.1词法阶段

定义在词法阶段的作用域是词法作用域，是由书写代码时变量和块作用域在哪决定的，大部分情况下词法分析器处理
代码时会保持作用域不变（大部分情况，严格模式另说）

### 2.2欺骗词法

`eval()`能够接收字符串并生成对应代码。
`with`根据传递的对象凭空创建一个全新的词法作用域。

### 2.3小结

两种修改词法作用域的方式都不推荐使用，一是容易降低代码的可读性，二是影响js引擎性能，因为引擎不能
在编译时对作用域查找进行优化。

## 第三章 函数作用域和块作用域

### 3.1隐藏内部实现

出于软件设计中的最小授权或最小暴露原则，不需要在全局作用域中能访问到所有变量和函数，正确的代码需要隐藏内部细节，只对外暴露必需的部分。另外，避免把
变量都放到全局作用域中，放到函数内部可以避免变量值被覆盖。

### 3.2隐藏的方式
+ 全局命名空间：比如第三方库会在全局作用域中声明一个名字独特的变量，该变量通常是一个对象，即第三方库的命名空间，所有对外暴露的功能都是该对象的属性。
+ 模块管理： 通过依赖管理器的机制将库的标识符显式地导入到特定的作用域中。在第五章会详细介绍。

### 3.3匿名函数和具名函数

匿名例子：
```javascript
setTimeout(function(){
    console.log("I waited 1 second")
}, 1000);
```

具名函数：   
```javascript
setTimeout(function timeoutHandler(){
    console.log("I waited 1 second")
}, 1000)
```

这两种方式的功能是一样的，不过出于调试和便于理解的角度，推荐具名函数的形式。

### 3.4立即执行函数

```javascript
// 这两种书写方式效果是相同的
(function func(global){
    // do something
})(window)

(function(window){
    // do something
}(window))
```

立即执行函数是一种保护私有变量的方式。

### 3.5块作用域

由于`var`定义的变量会被提升到作用域顶部，因此有必要限制变量的作用范围。使用`let`和`const`隐式地将变量作用域转为块作用域，这样变量将不会影响到
块作用域外的代码。

处于块作用域中的代码会在被执行后销毁，有利于垃圾回收：
```javascript
function process(data){
    // do something
}
{  // 对引擎来说，能够很清楚地知道块作用域中的someData不需要保留，使用后即销毁
    let someData = {}
    process(someData)
}
```

可以解决`for`循环打印变量的问题：

```javascript
// let将i绑定到了for循环的块中，并重新绑定到每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值
for(let i=0; i<10; i++){ 
    console.log(i)
}
```

本章还有一些有趣的技巧，详见书本内容。


